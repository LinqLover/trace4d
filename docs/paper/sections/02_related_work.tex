% !TeX root = ../paper.tex
\section{Related Work}
\label{sec:related_work}

Several approaches for visualizing the architecture and behavior of software systems have been proposed in the past.
In the broad field of program visualization~\cite{myers1986visual,sorva2013review,teyseyre2009overview}, \emph{algorithm animation} is an early approach that mainly focuses on visualizing procedural algorithms and data structures in educational contexts~\cite{brown1984system}.
During the last decades, more approaches have been proposed that allow to create general-purpose visualizations for the architecture and behavior of arbitrary software systems~\cite{reiss2006visualizing,cheng2008xdiva,chis2014moldable,devkota2022domain}.

\subsection{Software Architecture Visualization}

The term \emph{software maps} describes a family of approaches that use metaphors from cartography to visualize the architecture of software systems.

\paragraph{Treemaps}

\emph{Treemaps} display the static structure of software systems by visualizing their hierarchical organization of packages and classes, folders and files, autc. as a nested set of shapes~\cite{limberger2019advanced,limberger2022visual}.
They offer different visual variables such as the size, color, and position of the shapes to encode additional information about the system's size or evolution.
Shapes are usually rectangles but can also be polygons as in Voronoi tesselation treemaps~\cite{balzer2005voronoi}.
A popular modern type of treemaps is \emph{2.5D treemaps} that add a third dimension to the visualization by transforming each shape into a right prisma (usually cuboid) of a variable height.
Many approaches use the \emph{software city} metaphor to style the cuboids of a 2.5D treemap as buildings of a city~\cite{dugerdil2008execution,wettel2007visualizing,ardigo2021visualizing,mortara2021visualization,hoff2022utilizing,limberger2022visual}.

\paragraph{Topic maps}

Unless treemaps, \emph{topic maps} do not display the programmer-specified organization of a software system but use natural language processing techniques such as soruce code topic models, latent dirichlet allocation, and multidimensional scaling to arrange units of the software in a 2D or 3D graph~\cite{atzberger2023visualization}.
Different metaphors have been proposed to embody these graphs in a map, including boardgames~\cite{atzberger2022visualization} and landscapes such as forests~\cite{atzberger2021softwareforest} and galaxies~\cite{atzberger2021softwaregalaxies}.

\paragraph{Animated software maps}

Next to using static visual variables, some approaches enrich software maps with animations to display dynamic information over time~\cite[sec. 3.4]{lemieux2006visualization}.
Dynamic information can refer to the behavior or evolution of software:
for instance, \name{EvoSpaces}~\cite{dugerdil2008execution} highlights classes in a software city when they are activated, while \name{DynaCity}~\cite{dashuber2022trace}, \name{ExplorViz}~\cite{krause2021live}, \name{SynchroVis}~\cite{waller2013synchrovis}, and others~\cite{ciolkowski20173d} also draw connections between modules to visualize dataflow between them;
\Cite{langelier2008exploring} gradually constructs a software city and updates the geometries and colors of buildings to represent development activity, and \name{Gource}~\cite{caudwell2010gource} enhances the construction animation of a file tree with moving avatars representing code authors.
Some approaches allow programmers to monitor a system in real-time~\cite{fittkau2013live} while others replay a previously recorded trace of software activity~\cite{dugerdil2008execution}.

\subsection{Entity-Centric Behavior Visualization}

To provide visual insights into the behavior of software, a natural choice is to attribute behavior to different entities of the software.
Entities can be organizational units such as modules or classes but also individual object instances of object-oriented programs.

\paragraph{Object graphs}

Several tools allow programmers to explore relevant portions of a program's object graph~\cite{moreno2004visualizing,gestwicki2005methodology}.
Some graphs resemble the look of UML object diagrams and provide details about objects's internal state while others choose more compact representations.
To reduce the visual complexity of graph displays, some tools provide programmers with means for filtering objects based on their organization or relation to program slices~\cite{lange1997object,hamouLhadj2004survey}.

\paragraph{Communication flow}

\emph{Call graphs} and \emph{control-flow graphs} are two popular ways for displaying entities with their mutual dynamic interactions or communications~\cite{dePauw1998execution,lange1997object,lemieux2006visualization,reiss2007visual,tramnitzke2007object,boothe2011animation,prestin2022hidden}.
Entities can be nodes from an object graph or organizational units such as classes or modules.
\name{Avid} and \name{PathObjects}~\cite{schweizer2014pathobjects} provide animated object graphs where users can explore the control flow interactively.
\Cite{boothe2011animation} merges the stack frames from a control-flow graph and the nodes from an object graph into a single \emph{memeograph} that can be explored through animation.

In contrast to traditional call graphs, some works have proposed peripheral, hierarchical layouts of nodes such as \name{Extravis}' \emph{circular bundle views}~\cite{cornelissen2009trace} or \cite{munzner1997h3}'s 3D hyperbolic layout that provide better scaling for highly connected graphs.
Another representation of inter-entity communication is to provide full adjacency matrices of the call graph~\cite{dePauw1994modeling}. % TODO: Wrong source! Find right one or remove!

\paragraph{Dataflow}

Another perspective that can be taken on the object graph is how state is transferred through the system.
The \name{Whyline} approach allows programmers to ask questions about why certain behaviors did or did not happen or where certain values came from and presents the answers in a sliced control-flow graph~\cite{ko2008debugging}.
\Cite{lienhard2009taking} proposes an \emph{inter-unit flow view} that displays the amount of data or objects exchanged between different classes or modules in a directed weighted graph; this graph can also be embedded into a traditional call graph~\cite{lienhard2009flow}.

\paragraph{State changes}

\Cite{lienhard2009flow} also proposes a \emph{side-effects graph}~\cite{fierz2009compass} (also referred to as \emph{test blueprints}~\cite{lienhard2008test}) that displays connections between objects changing each other's state.
Similarly, \emph{object traces} describe a way to slice a call graph for exploring the state evolution of single objects~\cite{thiede2023object,thiede2023time}.

\subsection{Time-Centric Behavior Visualization}

Next to the communication between entities, another perspective that visualizations commonly take on software behavior is the temporal order of program execution.

\paragraph{Call trees}

A call tree is a hierarchy of stack frames or message sends that can be gained from a program trace.
Besides naive graph representations of this data structure, several approaches display call trees using hierarchical layouts such as treemaps, sunbursts, or \emph{icicle plots}~\cite{kruskal1983icicle,trumper2012viewfusion,woodburn2019interactive}.
Similarly to icicle plots, \emph{flame graphs} show the historical call stack over time, but they also assign colors to stack frames for displaying additional performance data from profiling tools~\cite{gregg2016flame}.

\paragraph{Sequential displays}

UML sequence diagrams are a traditional approach for displaying communication between objects over time.
Several tools adopt~\cite{syst√§2001shimba} and extend this diagram type~\cite{hamouLhadj2004survey}: for instance, \name{ISVis}' \emph{information mural}~\cite{jerding1998information} and \name{Extravis}' \emph{massive sequence view}~\cite{cornelissen2009trace} derive miniaturized versions of a sequence diagram~\cite[sec. 3.4]{lemieux2006visualization}, and \name{Ovation}~\cite{dePauw1998execution} detects execution patterns to reduce sequence diagrams~\cite{hamouLhadj2004survey}.

% TODO: Scan pptx for further sources
