% !TeX root = ../paper.tex
\section{Conclusion and Future Work}
\label{sec:conclusion}

In this paper, we proposed a novel approach to visualize the behavior of object-oriented programs through animated 2.5D object maps that depict particular objects and their interactions from a program trace.
We described the visual design of our approach and implemented it in a prototypical web application that displays program traces from a Squeak/Smalltalk environment.
We described how programmers can use our tool to explore the behavior of object-oriented programs and found that, especially for smaller and coherent program traces, they can gain several insights into the structure of the object graph and the segments of the program behavior while larger and more redundant program traces still pose practical challenges regarding the configuration of the object map, the clarity of the object graph, irrelevant details in the communication between objects, and the performance of the visualization.

While we used program traces from Squeak/Smalltalk in our prototype, it is not limited to this environment but could easily be applied to other object-oriented languages for which fine-grained (i.e., non-sampling) program tracers exist, such as Java (e.g., using \name{LiveRecorder}\footnote{\url{https://undo.io/}}), JavaScript (e.g., using \name{dbux}\footnote{\url{https://domiii.github.io/dbux/}}), or Python (e.g., using \name{PyTrace}\footnote{\url{https://pytrace.com/}}).

Although we have already seen promising results in our experience report, a user study with a larger number of participants and program traces is needed to thoroughly evaluate the potential and limitations of animated object maps for program comprehension.

In future work, we intend to scale our approach to larger program traces by experimenting with different (hierarchical) layout approaches~\cite{kuhn2008consistent,atzberger2023visualization}, automatic configuration heuristics, and trace summarization techniques~\cite{hamouLhadj2006summarizing,noda2017identifying} as well as by investing in technical optimizations of our prototype.
To further improve the compactness and overview of larger object graphs, we also consider defining state filters for hiding irrelevant fields of objects or defining conditions for aggregating similar objects into collapsed blocks.

Similarly, we hypothesize that the clarity of object graphs could benefit significantly from the use of domain-specific knowledge about the explored system~\cite{chis2014moldable}.
For example, particular domains such as the \code{Regex} engine or the \code{Morphic} UI framework could provide meaningful labels for objects (e.g., ``\textbackslash{}d'' instead of ``a RxsPredicate''), recommended filter presets, or structural hints (e.g., suggesting the use of the variables \code{submorphs} and \code{owner} to display the composite structure of a Morphic widget tree in the object map).

To explore the full potential of animated object maps for programmers, we want to integrate them into their usual development process by embedding the visualization into an IDE such as the Squeak/Smalltalk environment.
This would allow programmers to immediately~\cite{ungar1997debugging} switch between the program trace visualization and existing code browsing and debugging tools to take different views on the system under exploration; for example, they could open an animated object map from an omniscient debugger, select an object in the map to inspect it in an inspector tool, click on a stack frame in the flame graph to browse it in an editor, or even monitor a running program in the visualization.
In addition, this integration could improve the performance of our prototype, since data (e.g., the fields of filterable objects) could be streamed into the visualization on demand instead of serializing the entire trace in a single operation%
\footnote{In terms of our \tfd{} prototype, one implementation strategy for this would be to embed the web app in Squeak using the \name{MagicMouse} package (\url{https://github.com/cmfcmf/MagicMouse}) and exchange events and data through a WebSockets connection between the frontend and the backend.}%
.

Finally, we see another interesting research direction in encoding additional information about the system under exploration into the visualization.
For example, we could map domain-specific information or also static or dynamic software metrics to the color, size, or texture of object blocks to improve the recognizability and information of object regions or to make visible design quality issues or behavioral anomalies, resp.
By going beyond simple blocks and mapping different objects to individual glyphs such as bridges, construction cranes, or vehicles, we could also apply several metaphors based on the design and communication patterns of systems or their underlying domain to further improve intuitive recognition and understanding~\cite{cheng2008xdiva,wurfel2015natural}.
In particular, we could also make the evolution of the object graph visible by displaying and animating the historical state of objects~\cite{thiede2023object,thiede2023time}, adding and removing objects based on their lifecycle, and allowing programmers to navigate along the history of objects.
